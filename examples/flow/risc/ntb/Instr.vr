/*********************************************************************
 * SYNOPSYS CONFIDENTIAL                                             *
 *                                                                   *
 * This is an unpublished, proprietary work of Synopsys, Inc., and   *
 * is fully protected under copyright and trade secret laws. You may *
 * not view, use, disclose, copy, or distribute this file or any     *
 * information contained herein except pursuant to a valid written   *
 * license from Synopsys.                                            *
 *********************************************************************/

#include "regressions.vrh"
//risc8 instruction generation class


//enum declarations for all the risc8 instructions

enum loadacc {
  CLRW   = 12'd64,
  MOVLW  = 4'b1100
};

enum loadwfreg {
  MOVWF =6'b00_0000
};

enum bytetype {
  ANDLW  = 6'b11_1110,
  IORLW  = 6'b11_1101,
  XORLW  = 6'b11_1111,
  ADDWF  = 6'b00_0111,
  ANDWF  = 6'b00_0101,
  DECF   = 6'b00_0011,
  DECFSZ = 6'b00_1011,
  INCF   = 6'b00_1010,
  INCFSZ = 6'b00_1111,
  IORWF  = 6'b00_0100,
  RLF    = 6'b00_1101,
  XORWF  = 6'b00_0110,
  SWAPF  = 6'b00_1110,
  MOVF   = 6'b00_1000,
  COMF   = 6'b00_1001,
  SUBWF  = 6'b00_0010,
  CLRF   = 6'b00_0001,
  RRF    = 6'b00_1100
};

enum bittype {
  BCF    = 4'b0100,
  BSF    = 4'b0101,
  BTFSC  = 4'b0110,
  BTFSS  = 4'b0111
};

enum cntrltype {
  CALL1  = 4'b1001,
  GOTO   = 4'b1010,
  RETLW  = 4'b1000
};

enum indeptype {
  NOP    = 12'b0,
  SLEEP  = 12'b11,
  OPTION = 12'b10,
  CLRWDT = 12'b100,
  TRISA  = 12'b101,
  TRISB  = 12'b110,
  TRISC  = 12'b111
};


class instr { // start instruction class

  // class data members declarations
  //
  // class member declarations for opcode
  rand  loadacc    load_acc;
  rand  loadwfreg  loadw_freg;
  rand  bytetype   byte_type[4];
  rand  bittype    bit_type;
  rand  cntrltype  cntrl_type;
  rand  indeptype  indep_type;
  //
  // class memeber declaration for destination bit
  rand  bit  destination;
  //
  // class member declations for register address
  rand  bit [4:0] reg_address;
  //
  // class member declaration for register bit field
  rand  bit [2:0] bit_field;
  //
  // class member decalaration for memory bank
  rand  bit [1:0] bank;
  //
  // class member decalarations for k_field
  //
  rand  bit [7:0] k_field;
  //
  // class member declaration for internal registers to store the 12 bit instr
  bit [11:0] l_load_acc;
  bit [11:0] l_loadw_freg;
  bit [11:0] l_byte_type[4];
  bit [11:0] l_bit_type;
  bit [11:0] l_cntrl_type;
  bit [11:0] l_indep_type;
  bit [11:0] l_load_fsr;


  constraint const_k_field {
    (k_field > 8'd0);
    (k_field < 8'd255);
  }

  constraint const_bank {
    solve bank before reg_address;
    if(bank == 2'b00) { reg_address in { 5'h08:5'h1f};}
    if(bank != 2'b00) { reg_address in { 5'h0f:5'h1f};}
  }
  

  task post_randomize();
  task concat();
  
} // end of instruction class  


/*
  This post_ramdomize task is automatically called internally by
  Native Testbench, whenever we call randomize on the random class obj
*/

task instr::post_randomize()
 { // start of post randomize block
  concat();
 } // end of post randomize block


/*
  This concat task is used to concat all the randomized fields of
  an instruction and will make it a 12 bit single instruction.
  In our example we are randomizing the opcode, register address,
  bank,destination as separate variables.This concat task will
  concat the required above variables, and make them as a valid
  12 bit instruction.
  for example this taks will produce the following type of instructions

   <opcode><destination><register address>
   <opcode><bit position><register address>
   <opcode><literal value>
*/

task instr::concat()
 { // start of concat task
  integer k;

  // generate the instruction to choos the memory bank
  //
  l_load_fsr = {5'b11000,bank,5'b00000};

  //generate the instruction to load the FSR register
  //
  l_loadw_freg = {loadw_freg,1'b1,reg_address};

  // generate the bit type instruction
  //
  l_bit_type = {bit_type,bit_field,reg_address};

  // generate the independent instruction
  //
  l_indep_type = indep_type;

  // generate the instruction to load or clear the accumulator
  //
  if(load_acc == CLRW) {
    l_load_acc = load_acc;
  }
  else {
    l_load_acc = {load_acc,k_field};
  }

  //generate the byte type instructions
  //
  for(k=0;k<4;k=k+1) {
    if((byte_type[k]==ANDLW)||(byte_type[k]==IORLW)||(byte_type[k]==XORLW)) {
      l_byte_type[k] = {byte_type[k],k_field};
    }
    else
      if(byte_type[k]==CLRF) {
        l_byte_type[k] = {byte_type[k],1'b1,reg_address};
      }
      else {
        l_byte_type[k] = {byte_type[k],destination,reg_address};
      }
  } // end of forloop

} // end of concat task


