/*********************************************************************
 * SYNOPSYS CONFIDENTIAL                                             *
 *                                                                   *
 * This is an unpublished, proprietary work of Synopsys, Inc., and   *
 * is fully protected under copyright and trade secret laws. You may *
 * not view, use, disclose, copy, or distribute this file or any     *
 * information contained herein except pursuant to a valid written   *
 * license from Synopsys.                                            *
 *********************************************************************/

/*////////////////////////////////////////////////////////////////////////////
  
  This file has all the definitions of the monitor class, basic class, and
  the expansion class
  
  class monitor : has all the methods to monitor alu,decoder,the program flow
                  the accumulator, the program counter
  class basic   : has all the methods to run and control the basic test
  class exp     : has all the methods to run and control the exp circuit test

////////////////////////////////////////////////////////////////////////////*/

#define OUTPUT_EDGE  PHOLD
#define OUTPUT_SKEW  #1
#define INPUT_SKEW  #-1
#define INPUT_EDGE   PSAMPLE
#include <vera_defines.vrh>
#include "regressions.vrh"

#define MAX 234


/*
   The following Class object monitor has few methods that monitor
   various ports, registers, outputs and validate decode & arithmetic logic.
*/

class monitor
{ // class monitor starts here
  // declarations of all the members of monitor class
  //
  bit [7:0]  d_aluout;
  bit        d_cout;
  bit        d_zout;
  integer    d_cin;
  integer    d_a;
  integer    d_b;
  integer    d_op;

  // declarations of all the methods of monitor class
  task  validate_decode_logic();
  task  validate_arithmetic_logic();
  task  monitor_iodevice_ports();
  task  monitor_traffic();
  task  monitor_accumalator();
  task  monitor_program_counter();

} // class monitor ends here


/*  ************** CLASSES  at top level.  ****************** */

// ------ Class basic for the basic test  -------  //
class basic extends  monitor
{
  task  basic_directed_test();
}



// ------ Class exp for exp circuit test ------ //
class  exp extends  monitor
{
  task  exp_test();
}


// task definitions of the all the class methods declared above

/* 
  task to validate the decode logic.
  here the decode logic outputs opcode, destination from the design 
  are verified against those from reference C-model.
  Steps followed :At every negedge of clock
                  Get the Opcode from the design (d_op) using hdl task 
                  "get_alu"
                  Get the Opcode,destination from the C-model using 
                  C-function "decode_instruction"
                  Compare both the Opcodes and the destination.
*/

task  monitor::validate_decode_logic()
{ // task validate_decode_logic starts here
  // declaraion of internal variables of the task
  //
  integer   dest;
  string    mne;
  string    mnemonic;
  bit [3:0] c_opcode;

  fork
   {
     while(1) {
       @(negedge CLOCK);
       get_alu(d_aluout,d_cout,d_zout,d_a,d_b,d_op,d_cin);  // get design o/ps
       c_opcode=decode_instruction(test.debuginst,dest,mne); // get C-model o/ps
       mnemonic=mne; // taking mnemomic(output) of C-model into temp variable
       //program_flow_info(mnemonic); // call for task to print program flow
       // comparing opcodes from c-model and design(decoder)
       ASSERT(c_opcode == d_op)

       if(dest) // comparing the destination from both
         {
          @0,1 test.fwe == dest;
         }

       if(test.portbout==8'h08) // stop simulation for basic test if portb reaches last value expected
         { break; }
       else if(test.debugpc==11'h7FF) //stop simulation for random test by monitoring on Program counter
         { break; }

       if(test_plusargs("exp"))
         if(get_cycle()==MAX) // stop simulation for exp test
           { break; }
     }

   } join none
} // task validate_decode_logic ends here



/* 
  task to validate the Arithmetic logic for cpu execution. 
  Here the Arithmetic logic outputs, aluout, carry,zero flags 
  from the design are verified against those from reference C-model.
  Steps followed :At every negedge of clock
                  Get the aluouts from the design(d_aluout,d_zout,d_cout)
                  using hdl task "get_alu "
                  Get the aluouts(c_aluout,c_out,z_out) from the C-model
                  from C-function "alu"
                  Compare both using expects and asserts.
*/

task monitor::validate_arithmetic_logic()
{ // task validate_arithmetic_logic starts here
  //declaraion of internal variables of the task
  //
  integer   c_out;
  integer   z_out;
  bit [7:0] c_aluout;

  fork
    {
     while(1) {
       @(negedge CLOCK);
       get_alu(d_aluout,d_cout,d_zout,d_a,d_b,d_op,d_cin); // get design o/ps
       c_aluout=alu_dir(d_a,d_b,d_op,d_cin,c_out,z_out); // get alu o/ps
       ASSERT (z_out == d_zout) // compare zout from C-model & design
       ASSERT (c_out == d_cout) // compare cout from C-model & design
       @0,1 test.aluout == c_aluout; // compare aluout from C-model & design

       if(test.portbout==8'h08) // stop simulation for basic test if portb reaches last value expected
         { break; }
       else if(test.debugpc==11'h7FF) // stop simulation for random test by monitoring on Program counter
         { break; }

       if(test_plusargs("exp"))
       if(get_cycle()==MAX) // stop simulation for exp test
         { break; }
       
     }

  } join none

} // task validate_arithmetic_logic ends here



/*
  task which monitors the IOdevice ports (porta,portb,portc) for any 
  change in their values.This is done at every negedge of clock.
*/

task monitor::monitor_iodevice_ports()
{ // task monitor_iodevice_ports starts here
  // declarations of internal variables
  //
  bit [7:0] last_porta=8'hff; // initializing the internal regs to observe
  bit [7:0] last_portb=8'hff; // in the ports(a,b,c)
  bit [7:0] last_portc=8'hff;

  fork
   {
    while(1) {
      @(negedge CLOCK);
      if(last_portb != test.portbout) {
        printf("MONITOR_PORTB: Portb changes to %h\n",test.portbout);
        last_portb= test.portbout;
      }
      if(last_porta != test.portain) {
        printf("MONITOR_PORTA: Porta changes to %h\n",test.portain);
        last_porta =  test.portain;
      }
      if(last_portc != test.portcout) {
        printf("MONITOR_PORTC: Portc changes to %h\n",test.portcout);
        last_portc= test.portcout;
      }

      if(test.portbout==8'h08) // stop simulation for basic test if portb reaches last value expected
        { break; }
      if(test_plusargs("exp"))
      if(get_cycle()==MAX) // stop simulation for dds test
        { break; }
     
     }

  } join none

} // task monitor_iodevice_ports ends here


/* 
  task to monitor the traffic.
  Here the signals hwy, cntry are the traffic signal outputs from 
  the expansion circuit. 
*/

task monitor::monitor_traffic()
{ // task monitor_traffic starts here
  // declaraion of internal variables
  //
  bit[1:0] last_hwy=2'b10;   // initializing with some value
  bit[1:0] last_cntry=2'b10;

  fork
    {
     while(1) {
       @(negedge CLOCK);
       if(test.hwy != last_hwy) {
         printf("MONITOR_HWY: Hwy changes to %h\n\n",test.hwy);
         last_hwy=test.hwy;
       }
       if(test.cntry != last_cntry) {
         printf("MONITOR_CNTRY: Cntry  changes to %h\n\n",test.cntry);
         last_cntry=test.cntry;
       }

       if(test_plusargs("exp"))
       if(get_cycle()==MAX) // stop simulation for exp test
         { break; }
       
      }

  } join none

} // task monitor_traffic ends here



/*task to monitor any change in the accumulator at every negedge of the clock.*/

task monitor::monitor_accumalator()
{ // task monitor_accumalator starts here
  // declaration of internal variables
  //
  bit[7:0] last_w;

  fork
    {
     while(1) {
       @(negedge CLOCK);
       if(test.debugw == last_w) {
         printf("Accumalator= %0h  \n",test.debugw); 
       }
       last_w= test.debugw;
       if(test.portbout==8'h08) // stop simulation for basic test if portb reaches last value expected
         { break; }
       if(test_plusargs("exp"))
       if(get_cycle()==MAX) // stop simulation for exp test
         { break; }
       
      }

  } join none

} // task monitor_accumalator ends here



/* 
  task to monitor any change in the Program Counter
  at every negedge of the clock. 
*/

task monitor::monitor_program_counter()
{ // task monitor_program_counter starts here
  //
  fork
    {
     while(1) {
       @(negedge CLOCK);
       printf("Program_Counter =%0h\n",  test.debugpc); // observing PC
       if(test.portbout==8'h08) //stop simulation for basic test if portb reaches last value expected
         { break; }
       if(test_plusargs("exp"))
       if(get_cycle()==MAX) // stop simulation for exp test
         { break;}
       
      }

  } join none

} // task monitor_program_counter ends here



/* 
  external definition of the class_member of Basic which has 
  the complete program flow calls required for the basic test.   
*/

task basic::basic_directed_test()
{ // task basic_directed_test starts here
  //
  hdl_load_pram("../ntb/prog/basic.rom"); // hdltask call to load pram
  generate_reset(); // reset call

  printf("****** EXCUTION STARTS THE BASIC DIRECTED TEST ******\n");
  fork
    {
      {
       validate_decode_logic(); // call to compare idec results(C-model, design)
      }
      {
       validate_arithmetic_logic(); // call to compare alu (C-model, design)
      }
      {
       monitor_iodevice_ports();    // call for monitoring Ports
      }
      {
       verify_portb(); // call for verifying portb for the basic test
      }
      {
       drive_porta();  // call for driving porta
      }

    } join none

    wait_child();                  // Wait for the child process to complete
    printf("****** BASIC TEST : SUCCESSFUL ******\n");

} // task basic_directed_test ends here



/* 
  external definition of the class_member of Dds  which has 
  the complete program flow calls required for the dds test.   
*/

task exp::exp_test()
{ // task exp_test starts here
  //
  hdl_load_pram("../ntb/prog/controller.rom");  // hdltask call to load pram
  generate_reset(); // reset call

  printf("****** EXECUTION STARTS FOR THE EXP TEST ******\n");
  fork
    {
      {
       validate_decode_logic(); // call to compare idec results(C-model, design)
      }
      {
       validate_arithmetic_logic(); // call to compare alu (C-model, design)
      }
      {
       monitor_iodevice_ports();
      }
      {
       monitor_traffic(); // call for monitoring the outputs for dds test
      }
      {
       generate_traffic_detector();  // call for driving the exp
      }

    } join any 

    printf("***** EXP TEST : SUCCESSFUL *****\n");

} // task exp_test ends here

