/*********************************************************************
 * SYNOPSYS CONFIDENTIAL                                             *
 *                                                                   *
 * This is an unpublished, proprietary work of Synopsys, Inc., and   *
 * is fully protected under copyright and trade secret laws. You may *
 * not view, use, disclose, copy, or distribute this file or any     *
 * information contained herein except pursuant to a valid written   *
 * license from Synopsys.                                            *
 *********************************************************************/

bind instances th.duv.cntrlr_i : cntrlr
   (clk,
    reset,
    busAddr,
    rdWr_N,
    ce0_N,
    ce1_N,
    ce2_N,
    ce3_N,
    ramAddr,
    busData,
    ramData,
    adxStrb,
    busRdWr_N);
unit cntrlr 
         (logic clk,
          logic reset,
          logic [7:0] busAddr,
          logic rdWr_N,
          logic ce0_N,
          logic ce1_N,
          logic ce2_N,
          logic ce3_N,
          logic [5:0] ramAddr,
          logic [7:0] busData,
          logic [7:0] ramData,
          logic adxStrb,
          logic busRdWr_N);

//design signals: clk, reset, busAddr, busData, busRdWr_N, 
//       adxStrb, rdWr_N, ce0_N,
//	ce1_N, ce2_N, ce3_N, ramAddr, ramData);

     assert c_after_reset: check(e_after_reset);
     assert c_ce_mutex: check(e_ce_mutex);
     assert c_ce_pulse: check(e_ce_pulse); 
     assert c_no_ce_till_strb: check(e_no_ce_till_strb);
     assert c_rdWr_N_pulse: check(e_rdWr_N_pulse);
     assert c_addr_ok: check(e_addr_ok);
     assert c_ce0_decode: check(e_ce0_decode);
     assert c_ce_on_read: check(e_ce_on_read);
	 assert c_rd_addr_stable: check(e_rd_addr_stable);
     assert c_rd_data_ok: check(e_rd_data_ok);
     assert c_ce_on_write: check(e_ce_on_write);
     assert c_wr_addr_stable: check(e_wr_addr_stable);
     assert c_rdWr_N_on_write: check(e_rdWr_N_on_write);
     assert c_rdWr_N_idle: check(e_rdWr_N_idle);
     assert c_write_data_ok: check(e_write_data_ok);

// vacuity checks - checking for failures of assertions as well
// This is now handled using OVA functional coverage in 7.0

// fail on rising edge of ce_idle 
     //assert f_FAIL_on_posedge_ce_idle: forbid(e_FAIL_on_posedge_ce_idle);
// fail on reading
     //assert f_FAIL_on_reading: forbid(reading);
// fail on writing
     //assert f_FAIL_on_writing: forbid(writing);

  clock posedge clk {

     bool ce_idle:  (ce0_N && ce1_N && ce2_N && ce3_N);
     `define ce_mutex  (ce0_N || (ce1_N && ce2_N && ce3_N)) && (ce1_N || (ce2_N && ce3_N)) && (ce2_N || ce3_N) 
//     `define psedge_ce_idle  (posedge ce0_N) || (posedge ce1_N) || (posedge ce2_N) || (posedge ce3_N);
     event reading:  adxStrb && busRdWr_N && !reset;
     event writing:  adxStrb && !busRdWr_N && !reset;

     var [7:0] write_data; 
// Load write data when writing event, i.e., adxStrb && !busRdWr_N
     write_data <= (ended writing) ? busData : write_data; // test ended in var assign
//     write_data <= (adxStrb && !busRdWr_N && !reset) ? busData : write_data;

     var [7:0] addr_in; init addr_in = 8'b0; // init not really needed
// Load addr_in when adxStrb
     addr_in <= adxStrb ? busAddr : addr_in;

     var [7:0] read_data; init read_data = 8'b0;
// Load read_data when ce's not idle and a read operation
     read_data <= (!ce_idle && rdWr_N) ? ramData : read_data;


// After reset
// -----------

// no ce active and no write until first adxStrb
     event e_after_reset: if (negedge reset) then 
		 istrue ce_idle && rdWr_N in #[0..] adxStrb;

// Should also check that no driver active on ramData and busData 
// until it should be driven by write resp. read operation
// Must access bus driver enable signals in the design cntrlr.v
// TBC

// Global checks
// -------------

// ce's are mtually exclusive
     event e_ce_mutex: if !reset then (`ce_mutex);

// ce is a one clk cycle wide pulse
     event e_ce_pulse: if (!ce_idle && !reset) then #1 ce_idle;

// based on the two preceding checks, it is now enough to use (ce_idle)
//   as representing any ce

// after a ce is active, all must stay idle untilnext adxStrb
     event e_no_ce_till_strb: if (posedge ce_idle) then
				   ce_idle * [1..] #1 adxStrb;
     event e_FAIL_on_posedge_ce_idle: posedge ce_idle;

// Address is transferred correctly to the memory I/F
     event e_addr_ok: if !ce_idle && !reset then ramAddr == addr_in[5:0];

// Address is corectly  decoded to ce's
     event e_ce0_decode: if !ce_idle && !reset then 
		    !ce0_N && (addr_in[7:6] == 2'b00) ||
		    !ce1_N && (addr_in[7:6] == 2'b01) ||
		    !ce2_N && (addr_in[7:6] == 2'b10) ||
		    !ce3_N && (addr_in[7:6] == 2'b11);
     

// Read related properties
// -----------------------

// a ce is active 2 cycles  after reading command
     event e_ce_on_read: if (ended reading) then 
				(!ce_idle)*[2] #1 !ce_idle; //**ce_idle

// ram address is stable and rdWr_N for two cycles, 
// one cycle after adxStrb
// some redundancy with the Global address check
     event e_rd_addr_stable: if (ended reading) then 
	      #1 (rdWr_N && (ramAddr === addr_in[5:0])) * [2];

// read data appears 3 cycles after adxStrb
     event e_rd_data_ok: if (ended reading) then 
	      #3 (busData === read_data);


// busData driver must be off except for 1 cycle 
//   exactly 3 cycles after adxStrb
// must be checked on bus enable signals from the design
// TBC

// Write related properties
// ------------------------

// rdWr_N is a one clk cycle wide pulse
     event e_rdWr_N_pulse: if (!rdWr_N && !reset) then #1 rdWr_N;

// a ce_ is active for 1 cycle 3 cycles after writing command
     event e_ce_on_write: if (ended writing) then
		ce_idle * [3] #1 !ce_idle;

// ram address is stable and correct 1 cycle after writing
// and for 4 cycles
     event e_wr_addr_stable: if ended writing then
		#1 (ramAddr == addr_in[5:0]) * [4];

// ramRdWr_N is 0 3 cycles after writing
     event e_rdWr_N_on_write: if ended writing then
		rdWr_N * [3] #1 !rdWr_N;

// rdWr_N is 1 after 0 until adxStrb
     event e_rdWr_N_idle: if posedge rdWr_N then
		rdWr_N * [0..] #1 adxStrb;
// ramData is stable and correct 2 cycles after writing for 3 cycles
     event e_write_data_ok: if ended writing then
		#2 (ramData === write_data) * [2];
  }
endunit


