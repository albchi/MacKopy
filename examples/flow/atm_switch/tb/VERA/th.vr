/*********************************************************************
 * SYNOPSYS CONFIDENTIAL                                             *
 *                                                                   *
 * This is an unpublished, proprietary work of Synopsys, Inc., and   *
 * is fully protected under copyright and trade secret laws. You may *
 * not view, use, disclose, copy, or distribute this file or any     *
 * information contained herein except pursuant to a valid written   *
 * license from Synopsys.                                            *
 *********************************************************************/

//
//      Copyright (c) 2000 by Qualis Design Corporation. All rights reserved.
//      
//
//      This file contains licensed materials and may used and distributed
//      provided that this copyright statement is not removed from the file
//      and that any derivative work contains this copyright notice.
//
//      Qualis Design Corporation            Synopsys, Inc.
//      http://www.qualis.com                http://www.synopsys.com
//
// Description:
//      VERA test harness
//
// Author:      $Author: badri $
// Revision:    $Revision: 1.2 $
//

#include <vera_defines.vrh>

//
// Top level interfaces
//

interface top {
   input         clk       CLOCK verilog_node "th.clk";
   output        rst       PHOLD    #2 verilog_node "th.rst";
   input [31:0]  owner     PSAMPLE  #-1 verilog_node "th.duv.owner";
}

//
// Utopia receive interfaces
//

#ifdef SYSVERILOG_CONVERSION
interface utopia_rx_0 {
   input        clk    CLOCK verilog_node "th.rx_0.clk";
   output [7:0] data   PHOLD   #1 verilog_node "th.rx_0.data";
   output       soc    PHOLD   #1 verilog_node "th.rx_0.soc";
   input        en     PSAMPLE #-10 verilog_node "th.rx_0.en";
   output       empty  PHOLD   #1 verilog_node "th.rx_0.empty_full";
}
interface utopia_rx_1 {
   input        clk    CLOCK verilog_node "th.rx_1.clk";
   output [7:0] data   PHOLD   #1 verilog_node "th.rx_1.data";
   output       soc    PHOLD   #1 verilog_node "th.rx_1.soc";
   input        en     PSAMPLE #-10 verilog_node "th.rx_1.en";
   output       empty  PHOLD   #1 verilog_node "th.rx_1.empty_full";
}
interface utopia_rx_2 {
   input        clk    CLOCK verilog_node "th.rx_2.clk";
   output [7:0] data   PHOLD   #1 verilog_node "th.rx_2.data";
   output       soc    PHOLD   #1 verilog_node "th.rx_2.soc";
   input        en     PSAMPLE #-10 verilog_node "th.rx_2.en";
   output       empty  PHOLD   #1 verilog_node "th.rx_2.empty_full";
}
interface utopia_rx_3 {
   input        clk    CLOCK verilog_node "th.rx_3.clk";
   output [7:0] data   PHOLD   #1 verilog_node "th.rx_3.data";
   output       soc    PHOLD   #1 verilog_node "th.rx_3.soc";
   input        en     PSAMPLE #-10 verilog_node "th.rx_3.en";
   output       empty  PHOLD   #1 verilog_node "th.rx_3.empty_full";
}
interface utopia_rx_4 {
   input        clk    CLOCK verilog_node "th.rx_4.clk";
   output [7:0] data   PHOLD   #1 verilog_node "th.rx_4.data";
   output       soc    PHOLD   #1 verilog_node "th.rx_4.soc";
   input        en     PSAMPLE #-10 verilog_node "th.rx_4.en";
   output       empty  PHOLD   #1 verilog_node "th.rx_4.empty_full";
}
interface utopia_rx_5 {
   input        clk    CLOCK verilog_node "th.rx_5.clk";
   output [7:0] data   PHOLD   #1 verilog_node "th.rx_5.data";
   output       soc    PHOLD   #1 verilog_node "th.rx_5.soc";
   input        en     PSAMPLE #-10 verilog_node "th.rx_5.en";
   output       empty  PHOLD   #1 verilog_node "th.rx_5.empty_full";
}
interface utopia_rx_6 {
   input        clk    CLOCK verilog_node "th.rx_6.clk";
   output [7:0] data   PHOLD   #1 verilog_node "th.rx_6.data";
   output       soc    PHOLD   #1 verilog_node "th.rx_6.soc";
   input        en     PSAMPLE #-10 verilog_node "th.rx_6.en";
   output       empty  PHOLD   #1 verilog_node "th.rx_6.empty_full";
}
interface utopia_rx_7 {
   input        clk    CLOCK verilog_node "th.rx_7.clk";
   output [7:0] data   PHOLD   #1 verilog_node "th.rx_7.data";
   output       soc    PHOLD   #1 verilog_node "th.rx_7.soc";
   input        en     PSAMPLE #-10 verilog_node "th.rx_7.en";
   output       empty  PHOLD   #1 verilog_node "th.rx_7.empty_full";
}


//
// Utopia transmit interfaces
//

interface utopia_tx_0 {
   input       clk    CLOCK verilog_node "th.tx_0.clk";
   input [7:0] data   PSAMPLE #-10 verilog_node "th.tx_0.data";
   input       soc    PSAMPLE #-10 verilog_node "th.tx_0.soc";
   input       en     PSAMPLE #-10 verilog_node "th.tx_0.en";
   output      full   PHOLD   #1 verilog_node "th.tx_0.empty_full";
}
interface utopia_tx_1 {
   input       clk    CLOCK verilog_node "th.tx_1.clk";
   input [7:0] data   PSAMPLE #-10 verilog_node "th.tx_1.data";
   input       soc    PSAMPLE #-10 verilog_node "th.tx_1.soc";
   input       en     PSAMPLE #-10 verilog_node "th.tx_1.en";
   output      full   PHOLD   #1 verilog_node "th.tx_1.empty_full";
}
interface utopia_tx_2 {
   input       clk    CLOCK verilog_node "th.tx_2.clk";
   input [7:0] data   PSAMPLE #-10 verilog_node "th.tx_2.data";
   input       soc    PSAMPLE #-10 verilog_node "th.tx_2.soc";
   input       en     PSAMPLE #-10 verilog_node "th.tx_2.en";
   output      full   PHOLD   #1 verilog_node "th.tx_2.empty_full";
}
interface utopia_tx_3 {
   input       clk    CLOCK verilog_node "th.tx_3.clk";
   input [7:0] data   PSAMPLE #-10 verilog_node "th.tx_3.data";
   input       soc    PSAMPLE #-10 verilog_node "th.tx_3.soc";
   input       en     PSAMPLE #-10 verilog_node "th.tx_3.en";
   output      full   PHOLD   #1 verilog_node "th.tx_3.empty_full";
}
interface utopia_tx_4 {
   input       clk    CLOCK verilog_node "th.tx_4.clk";
   input [7:0] data   PSAMPLE #-10 verilog_node "th.tx_4.data";
   input       soc    PSAMPLE #-10 verilog_node "th.tx_4.soc";
   input       en     PSAMPLE #-10 verilog_node "th.tx_4.en";
   output      full   PHOLD   #1 verilog_node "th.tx_4.empty_full";
}
interface utopia_tx_5 {
   input       clk    CLOCK verilog_node "th.tx_5.clk";
   input [7:0] data   PSAMPLE #-10 verilog_node "th.tx_5.data";
   input       soc    PSAMPLE #-10 verilog_node "th.tx_5.soc";
   input       en     PSAMPLE #-10 verilog_node "th.tx_5.en";
   output      full   PHOLD   #1 verilog_node "th.tx_5.empty_full";
}
interface utopia_tx_6 {
   input       clk    CLOCK verilog_node "th.tx_6.clk";
   input [7:0] data   PSAMPLE #-10 verilog_node "th.tx_6.data";
   input       soc    PSAMPLE #-10 verilog_node "th.tx_6.soc";
   input       en     PSAMPLE #-10 verilog_node "th.tx_6.en";
   output      full   PHOLD   #1 verilog_node "th.tx_6.empty_full";
}
interface utopia_tx_7 {
   input       clk    CLOCK verilog_node "th.tx_7.clk";
   input [7:0] data   PSAMPLE #-10 verilog_node "th.tx_7.data";
   input       soc    PSAMPLE #-10 verilog_node "th.tx_7.soc";
   input       en     PSAMPLE #-10 verilog_node "th.tx_7.en";
   output      full   PHOLD   #1 verilog_node "th.tx_7.empty_full";
}

#else
interface utopia_rx_0 {
   input        clk    CLOCK verilog_node "th.Rx_clk_0";
   output [7:0] data   PHOLD   #1 verilog_node "th.Rx_data_0";
   output       soc    PHOLD   #1 verilog_node "th.Rx_soc_0";
   input        en     PSAMPLE #-10 verilog_node "th.Rx_en_0";
   output       empty  PHOLD   #1 verilog_node "th.Rx_empty_0";
}
interface utopia_rx_1 {
   input        clk    CLOCK verilog_node "th.Rx_clk_1";
   output [7:0] data   PHOLD   #1 verilog_node "th.Rx_data_1";
   output       soc    PHOLD   #1 verilog_node "th.Rx_soc_1";
   input        en     PSAMPLE #-10 verilog_node "th.Rx_en_1";
   output       empty  PHOLD   #1 verilog_node "th.Rx_empty_1";
}
interface utopia_rx_2 {
   input        clk    CLOCK verilog_node "th.Rx_clk_2";
   output [7:0] data   PHOLD   #1 verilog_node "th.Rx_data_2";
   output       soc    PHOLD   #1 verilog_node "th.Rx_soc_2";
   input        en     PSAMPLE #-10 verilog_node "th.Rx_en_2";
   output       empty  PHOLD   #1 verilog_node "th.Rx_empty_2";
}
interface utopia_rx_3 {
   input        clk    CLOCK verilog_node "th.Rx_clk_3";
   output [7:0] data   PHOLD   #1 verilog_node "th.Rx_data_3";
   output       soc    PHOLD   #1 verilog_node "th.Rx_soc_3";
   input        en     PSAMPLE #-10 verilog_node "th.Rx_en_3";
   output       empty  PHOLD   #1 verilog_node "th.Rx_empty_3";
}
interface utopia_rx_4 {
   input        clk    CLOCK verilog_node "th.Rx_clk_4";
   output [7:0] data   PHOLD   #1 verilog_node "th.Rx_data_4";
   output       soc    PHOLD   #1 verilog_node "th.Rx_soc_4";
   input        en     PSAMPLE #-10 verilog_node "th.Rx_en_4";
   output       empty  PHOLD   #1 verilog_node "th.Rx_empty_4";
}
interface utopia_rx_5 {
   input        clk    CLOCK verilog_node "th.Rx_clk_5";
   output [7:0] data   PHOLD   #1 verilog_node "th.Rx_data_5";
   output       soc    PHOLD   #1 verilog_node "th.Rx_soc_5";
   input        en     PSAMPLE #-10 verilog_node "th.Rx_en_5";
   output       empty  PHOLD   #1 verilog_node "th.Rx_empty_5";
}
interface utopia_rx_6 {
   input        clk    CLOCK verilog_node "th.Rx_clk_6";
   output [7:0] data   PHOLD   #1 verilog_node "th.Rx_data_6";
   output       soc    PHOLD   #1 verilog_node "th.Rx_soc_6";
   input        en     PSAMPLE #-10 verilog_node "th.Rx_en_6";
   output       empty  PHOLD   #1 verilog_node "th.Rx_empty_6";
}
interface utopia_rx_7 {
   input        clk    CLOCK verilog_node "th.Rx_clk_7";
   output [7:0] data   PHOLD   #1 verilog_node "th.Rx_data_7";
   output       soc    PHOLD   #1 verilog_node "th.Rx_soc_7";
   input        en     PSAMPLE #-10 verilog_node "th.Rx_en_7";
   output       empty  PHOLD   #1 verilog_node "th.Rx_empty_7";
}


//
// Utopia transmit interfaces
//

interface utopia_tx_0 {
   input       clk    CLOCK verilog_node "th.Tx_clk_0";
   input [7:0] data   PSAMPLE #-10 verilog_node "th.Tx_data_0";
   input       soc    PSAMPLE #-10 verilog_node "th.Tx_soc_0";
   input       en     PSAMPLE #-10 verilog_node "th.Tx_en_0";
   output      full   PHOLD   #1 verilog_node "th.Tx_full_0";
}
interface utopia_tx_1 {
   input       clk    CLOCK verilog_node "th.Tx_clk_1";
   input [7:0] data   PSAMPLE #-10 verilog_node "th.Tx_data_1";
   input       soc    PSAMPLE #-10 verilog_node "th.Tx_soc_1";
   input       en     PSAMPLE #-10 verilog_node "th.Tx_en_1";
   output      full   PHOLD   #1 verilog_node "th.Tx_full_1";
}
interface utopia_tx_2 {
   input       clk    CLOCK verilog_node "th.Tx_clk_2";
   input [7:0] data   PSAMPLE #-10 verilog_node "th.Tx_data_2";
   input       soc    PSAMPLE #-10 verilog_node "th.Tx_soc_2";
   input       en     PSAMPLE #-10 verilog_node "th.Tx_en_2";
   output      full   PHOLD   #1 verilog_node "th.Tx_full_2";
}
interface utopia_tx_3 {
   input       clk    CLOCK verilog_node "th.Tx_clk_3";
   input [7:0] data   PSAMPLE #-10 verilog_node "th.Tx_data_3";
   input       soc    PSAMPLE #-10 verilog_node "th.Tx_soc_3";
   input       en     PSAMPLE #-10 verilog_node "th.Tx_en_3";
   output      full   PHOLD   #1 verilog_node "th.Tx_full_3";
}
interface utopia_tx_4 {
   input       clk    CLOCK verilog_node "th.Tx_clk_4";
   input [7:0] data   PSAMPLE #-10 verilog_node "th.Tx_data_4";
   input       soc    PSAMPLE #-10 verilog_node "th.Tx_soc_4";
   input       en     PSAMPLE #-10 verilog_node "th.Tx_en_4";
   output      full   PHOLD   #1 verilog_node "th.Tx_full_4";
}
interface utopia_tx_5 {
   input       clk    CLOCK verilog_node "th.Tx_clk_5";
   input [7:0] data   PSAMPLE #-10 verilog_node "th.Tx_data_5";
   input       soc    PSAMPLE #-10 verilog_node "th.Tx_soc_5";
   input       en     PSAMPLE #-10 verilog_node "th.Tx_en_5";
   output      full   PHOLD   #1 verilog_node "th.Tx_full_5";
}
interface utopia_tx_6 {
   input       clk    CLOCK verilog_node "th.Tx_clk_6";
   input [7:0] data   PSAMPLE #-10 verilog_node "th.Tx_data_6";
   input       soc    PSAMPLE #-10 verilog_node "th.Tx_soc_6";
   input       en     PSAMPLE #-10 verilog_node "th.Tx_en_6";
   output      full   PHOLD   #1 verilog_node "th.Tx_full_6";
}
interface utopia_tx_7 {
   input       clk    CLOCK verilog_node "th.Tx_clk_7";
   input [7:0] data   PSAMPLE #-10 verilog_node "th.Tx_data_7";
   input       soc    PSAMPLE #-10 verilog_node "th.Tx_soc_7";
   input       en     PSAMPLE #-10 verilog_node "th.Tx_en_7";
   output      full   PHOLD   #1 verilog_node "th.Tx_full_7";
}

#endif


//
// Bind virtual ports to physical interfaces
//
#ifdef NTB
#else
#include "syslog.vrh"
#include "list.vrh"
#include "atm_cell.vrh"
#include "utopia_phy_tx.vrh"
#include "utopia_phy_rx.vrh"
#endif

bind utopia_rx_port utopia_rx_port_0 {
   data          utopia_rx_0.data;
   soc           utopia_rx_0.soc;
   enb           utopia_rx_0.en;
   empty_clav    utopia_rx_0.empty;
   clk           utopia_rx_0.clk;
}
bind utopia_rx_port utopia_rx_port_1 {
   data          utopia_rx_1.data;
   soc           utopia_rx_1.soc;
   enb           utopia_rx_1.en;
   empty_clav    utopia_rx_1.empty;
   clk           utopia_rx_1.clk;
}
bind utopia_rx_port utopia_rx_port_2 {
   data          utopia_rx_2.data;
   soc           utopia_rx_2.soc;
   enb           utopia_rx_2.en;
   empty_clav    utopia_rx_2.empty;
   clk           utopia_rx_2.clk;
}
bind utopia_rx_port utopia_rx_port_3 {
   data          utopia_rx_3.data;
   soc           utopia_rx_3.soc;
   enb           utopia_rx_3.en;
   empty_clav    utopia_rx_3.empty;
   clk           utopia_rx_3.clk;
}
bind utopia_rx_port utopia_rx_port_4 {
   data          utopia_rx_4.data;
   soc           utopia_rx_4.soc;
   enb           utopia_rx_4.en;
   empty_clav    utopia_rx_4.empty;
   clk           utopia_rx_4.clk;
}
bind utopia_rx_port utopia_rx_port_5 {
   data          utopia_rx_5.data;
   soc           utopia_rx_5.soc;
   enb           utopia_rx_5.en;
   empty_clav    utopia_rx_5.empty;
   clk           utopia_rx_5.clk;
}
bind utopia_rx_port utopia_rx_port_6 {
   data          utopia_rx_6.data;
   soc           utopia_rx_6.soc;
   enb           utopia_rx_6.en;
   empty_clav    utopia_rx_6.empty;
   clk           utopia_rx_6.clk;
}
bind utopia_rx_port utopia_rx_port_7 {
   data          utopia_rx_7.data;
   soc           utopia_rx_7.soc;
   enb           utopia_rx_7.en;
   empty_clav    utopia_rx_7.empty;
   clk           utopia_rx_7.clk;
}


bind utopia_tx_port utopia_tx_port_0 {
   data         utopia_tx_0.data;
   soc          utopia_tx_0.soc;
   enb          utopia_tx_0.en;
   full_clav    utopia_tx_0.full;
   clk          utopia_tx_0.clk;
}
bind utopia_tx_port utopia_tx_port_1 {
   data         utopia_tx_1.data;
   soc          utopia_tx_1.soc;
   enb          utopia_tx_1.en;
   full_clav    utopia_tx_1.full;
   clk          utopia_tx_1.clk;
}
bind utopia_tx_port utopia_tx_port_2 {
   data         utopia_tx_2.data;
   soc          utopia_tx_2.soc;
   enb          utopia_tx_2.en;
   full_clav    utopia_tx_2.full;
   clk          utopia_tx_2.clk;
}
bind utopia_tx_port utopia_tx_port_3 {
   data         utopia_tx_3.data;
   soc          utopia_tx_3.soc;
   enb          utopia_tx_3.en;
   full_clav    utopia_tx_3.full;
   clk          utopia_tx_3.clk;
}
bind utopia_tx_port utopia_tx_port_4 {
   data         utopia_tx_4.data;
   soc          utopia_tx_4.soc;
   enb          utopia_tx_4.en;
   full_clav    utopia_tx_4.full;
   clk          utopia_tx_4.clk;
}
bind utopia_tx_port utopia_tx_port_5 {
   data         utopia_tx_5.data;
   soc          utopia_tx_5.soc;
   enb          utopia_tx_5.en;
   full_clav    utopia_tx_5.full;
   clk          utopia_tx_5.clk;
}
bind utopia_tx_port utopia_tx_port_6 {
   data         utopia_tx_6.data;
   soc          utopia_tx_6.soc;
   enb          utopia_tx_6.en;
   full_clav    utopia_tx_6.full;
   clk          utopia_tx_6.clk;
}
bind utopia_tx_port utopia_tx_port_7 {
   data         utopia_tx_7.data;
   soc          utopia_tx_7.soc;
   enb          utopia_tx_7.en;
   full_clav    utopia_tx_7.full;
   clk          utopia_tx_7.clk;
}


//--------------------------------------------------------
//
// Test harness object
//

// write switching context to memory for specified VPI
verilog_task vera_sc_write(reg[7:0] vpi, reg[15:0] sc_mask) "th.duv.sc_write";

// read QoS memory for cell statistic
verilog_task vera_qos_read(reg[7:0] vpi, var reg[15:0] qos_data) "th.duv.qos_read";


class harness {
   syslog          log;
   utopia_phy_tx   atm_gen[8];
   utopia_phy_rx   atm_mon[8];
   
   task new();
   task reset();
   task sc_write(reg[7:0] vpi, reg[15:0] sc_mask);
   task qos_read(reg[7:0] vpi, var reg[15:0] qos_data);
}


//--------------------------------------------------------
//
// Main program for all testcases
//

//
// Prototype for all testcase functions
//


#ifdef NTB
#else
  extern function integer testcase(harness h);
#endif

program main
{
   integer status;

   // Invoke the testcase with an instance of the harness,
   // returning the testcase's return code
   harness h;

   h = new;

   printf("Resetting TH\n");
   h.reset();

   printf("Starting testcase\n");
   status = testcase(h);
   h.log.report("all");
   
   exit(status);
}


//--------------------------------------------------------
//
// Class Implementation
//

task harness::new()
{
   log = new("Test Harness");

   atm_gen[0] = new(utopia_rx_port_0, "PHY Tx 0");
   atm_gen[1] = new(utopia_rx_port_1, "PHY Tx 1");
   atm_gen[2] = new(utopia_rx_port_2, "PHY Tx 2");
   atm_gen[3] = new(utopia_rx_port_3, "PHY Tx 3");
   atm_gen[4] = new(utopia_rx_port_4, "PHY Tx 4");
   atm_gen[5] = new(utopia_rx_port_5, "PHY Tx 5");
   atm_gen[6] = new(utopia_rx_port_6, "PHY Tx 6");
   atm_gen[7] = new(utopia_rx_port_7, "PHY Tx 7");

   atm_mon[0] = new(utopia_tx_port_0, "PHY Rx 0");
   atm_mon[1] = new(utopia_tx_port_1, "PHY Rx 1");
   atm_mon[2] = new(utopia_tx_port_2, "PHY Rx 2");
   atm_mon[3] = new(utopia_tx_port_3, "PHY Rx 3");
   atm_mon[4] = new(utopia_tx_port_4, "PHY Rx 4");
   atm_mon[5] = new(utopia_tx_port_5, "PHY Rx 5");
   atm_mon[6] = new(utopia_tx_port_6, "PHY Rx 6");
   atm_mon[7] = new(utopia_tx_port_7, "PHY Rx 7");
}

task harness::reset()
{
  top.rst = 1'b0;
  repeat (30) @(posedge top.clk);
  top.rst = 1'b1;
  repeat (10) @(posedge top.clk);
  top.rst = 1'b0;
}

task harness::sc_write(reg[7:0] vpi, reg[15:0] sc_mask)
{
  vera_sc_write(vpi, sc_mask);
}

task harness::qos_read(reg[7:0] vpi, var reg[15:0] qos_data)
{
  vera_qos_read(vpi, qos_data);
}

