/*********************************************************************
 * SYNOPSYS CONFIDENTIAL                                             *
 *                                                                   *
 * This is an unpublished, proprietary work of Synopsys, Inc., and   *
 * is fully protected under copyright and trade secret laws. You may *
 * not view, use, disclose, copy, or distribute this file or any     *
 * information contained herein except pursuant to a valid written   *
 * license from Synopsys.                                            *
 *********************************************************************/

//
//	Copyright (c) 2000 Qualis Design Corporation.
//	All rights reserved.
//
//	Qualis Design Corporation
//	PO Box 4444
//	Beaverton OR 97075-4444
//	Phone: +1-503-670-9700
//	E-mail: info@qualis.com
//	World Wide Web: http://www.qualis.com	
//
// Description:
//      Message log object
//
// Author:      $Author: badri $
// Revision:    $Revision: 1.2 $
//

#include <vera_defines.vrh>


class syslog {
   //
   // Symbolic constants
   //
   static local integer WARNING = 0;
   static local integer ERROR   = 1;
    
   //
   // Global control parameters
   //
   static local integer   max_err_cnt  = 0;  // Stop when # of unexp. errs
   static local integer   log_cnt      = 0;  // # of known logs
   static local syslog    known_log[];       // List of known logs    

   //
   // Local control parameters
   //
   local string  name;                // Name for this object
   local reg     dbg_on;              // Turn on debug messages
   local integer err_cnt    = 0;      // # of unexp. errors
   local integer expected[2];         // # of expected messages
   local integer missed[2];           // # of expected messages missed

   //
   // Message management
   //
   // Some management methods can be applied to a named logger.
   // The specified name must match a known logger. The
   // name "this" indicates this logger. The name "all" indicates
   // all known loggers.
   //
   // For example, to have all loggers report their status:
   //        log.report("all");
   //
   task new(string name);
   
   task expect(integer n_warns = 0,       // Expect # of warns
               integer n_errs  = 0,       // and # of errs
               string  which   = "this"); // on this named logger
   task set_debug(reg on_off = 0,
                  string which  = "this"); // Turn dbg messages on/off
   task report(string which    = "this"); // Report status

   //
   // Issue messages
   //
   task debug(string msg = "");
   task note(string msg = "");
   task warning(string msg = "");
   task error(string msg = "");
   task fatal(string msg = "");

   //
   // Private methods
   //
   local task incr_err_cnt();
}


//
// Allocate a new logger
//
task syslog::new(string name)
{
    integer i;

    this.name = name;
    known_log[log_cnt++] = this;

    this.err_cnt         = 0;
    
    this.expected[WARNING] = 0;
    this.expected[ERROR]   = 0;

    this.missed[WARNING] = 0;
    this.missed[ERROR]   = 0;
}


//
// Define how many errors and warnings are to be expected
// until the next call to this method or report()
//
task syslog::expect(integer n_warns = 0,
                    integer n_errs  = 0,
                    string  which   = "this")
{
   syslog log;
   
   // Find the logger in question - "all" is not valid here
   if (which == "this") {
      log = this;
   } else {
      integer ok;
      integer i;
      
      for(ok = assoc_index(FIRST, known_log, i); ok;
          ok = assoc_index(NEXT, known_log, i)) {
         if (known_log[i].name == which) break;
      }
      if (!ok) {
         this.warning();
         printf("Cannot set expectation on for %s: unknown logger\n",
                 which);
         return;
      }
      log = known_log[i];
   }
   
   //
   // Do we have pending expected warnings or errors
   // that were not issues? In which case, that is also
   // an error.
   //
    if (log.expected[WARNING] > 0) {
       printf("*ERROR* on %s at %d:",
              log.name, get_time(LO));
       printf("%0d warning missed\n",
              (log.expected[WARNING] > 1) ? "s were" : "was");
       log.missed[WARNING] += log.expected[WARNING];
       log.incr_err_cnt();
    }

    if (log.expected[ERROR] > 0) {
       printf("*ERROR* on %s at %d:",
              log.name, get_time(LO));
       printf("%0d error%0s missed\n",
              log.expected[ERROR],
              (log.expected[ERROR] > 1) ? "s were" : "was");
       log.missed[ERROR] += log.expected[ERROR];
       log.incr_err_cnt();
    }

    //
    // Set and report the new number of expected warnings and errors
    //
    log.expected[WARNING] = n_warns;
    log.expected[ERROR]   = n_errs;

    printf("expect! on %s at %d:",
	   log.name, get_time(LO));
    printf("Expecting %0d warning%0s and %0derror%0s\n",
           log.expected[WARNING], (log.expected[WARNING]>1) ? "s" : "",
	   log.expected[ERROR], (log.expected[ERROR]>1) ? "s" : "");
}


//
// Display error message and increment error count.
// 
task syslog::error(string msg = "")
{
   //
   // If this is an expected error, downplay it.
   //
   if (this.expected[ERROR] > 0) { 
      if (msg != "") 
		  printf("exp err on %s at %d: %s\n",
             this.name, get_time(LO), msg);
      else
		  printf("exp err on %s at %d: ",
             this.name, get_time(LO));
      this.expected[ERROR]--;
   } else {
      if (msg != "") 
		  printf("*ERROR* on %s at %d: %s\n",
             this.name, get_time(LO), msg);
      else
		  printf("*ERROR* on %s at %d: ",
             this.name, get_time(LO));
      this.incr_err_cnt();
   }
}

//
// Display the fatal error message and exit
//
task syslog::fatal(string msg = "")
{
   printf("*FATAL* on %s at %d: %s\n",
          this.name, get_time(LO), msg);
   exit(-1);
}


//
// Display warning message
//
task syslog::warning(string msg = "")
{
   //
   // If this is an expected warning, downplay it.
   //
   if (this.expected[WARNING] > 0) { 
      if (msg != "")
		  printf("exp wrn on %s at %d: %s\n",
             this.name, get_time(LO), msg);
      else
		  printf("exp wrn on %s at %d: ",
             this.name, get_time(LO));
      
      this.expected[WARNING]--;
   } else {
      if (msg != "")
		  printf("WARNING on %s at %d: %s\n",
             this.name, get_time(LO), msg);
      else
		  printf("WARNING on %s at %d: ",
             this.name, get_time(LO));
   }
}

//
// Display a notification message
//
task syslog::note(string msg = "")
{
   if (msg != "")
	   printf("note... on %s at %d cycle %d: %s\n",
			  this.name, get_time(LO), get_cycle(), msg);
   else
	   printf("note... on %s at %d cycle %d: ",
			  this.name, get_time(LO), get_cycle());
}

//
// Display a debug message if enabled
//
task syslog::debug(string msg = "")
{
   if (dbg_on) {
      printf("-debug- on %s at %d: %s\n",
             this.name, get_time(LO), msg);
   }
}


//
// Turn debug messages on/off for the named logger
//
task syslog::set_debug(reg on_off    = 0,
                       string which  = "this")
{
   //
   // If this is for all logger,
   // set debug flag for all of them
   //
   if (which == "all") {
      integer ok;
      integer i;
      
      for(ok = assoc_index(FIRST, known_log, i); ok;
          ok = assoc_index(NEXT, known_log, i)) {
         known_log[i].dbg_on = on_off;
      }
   } else {
      syslog log;
      // Find the named logger
      if (which == "this") {
         this.dbg_on = on_off;
      } else {
         integer ok;
         integer i;

         for(ok = assoc_index(FIRST, known_log, i); ok;
             ok = assoc_index(NEXT, known_log, i)) {
            if (known_log[i].name == which) break;
         }
         if (!ok) {
            this.warning();
            printf("Cannot turn debug on for %s: unknown logger\n",
                    which);
            return;
         }
         known_log[i].dbg_on = on_off;
      }
   }
}


//
// Report status of the named logger
//
task syslog::report(string which = "this")
{
   integer err_cnt    = 0;
   integer missed_err = 0;
   integer missed_wrn = 0;
   
   //
   // If this is for all logger,
   // compile a summary status
   //
   if (which == "all") {
      integer ok;
      integer i;
      
      for(ok = assoc_index(FIRST, known_log, i); ok;
          ok = assoc_index(NEXT, known_log, i)) {
         err_cnt    += known_log[i].err_cnt;
         missed_err += known_log[i].missed[ERROR] +
                       known_log[i].expected[ERROR];
         missed_wrn += known_log[i].missed[WARNING] +
                       known_log[i].expected[WARNING];
      }
   } else {
      syslog log;
      
      // Find the named logger
      if (which == "this") {
         log   = this;
         which = this.name;
      } else {
         integer ok;
         integer i;
         
         for(ok = assoc_index(FIRST, known_log, i); ok;
             ok = assoc_index(NEXT, known_log, i)) {
            if (known_log[i].name == which) break;
         }
         if (!ok) {
            printf("FAILED! on %s at %d: unknown logger\n",
                   get_time(LO), which);
            return;
         }
         log = known_log[i];
      }

      err_cnt    = log.err_cnt;
      missed_err = log.missed[ERROR]   + log.expected[ERROR];
      missed_wrn = log.missed[WARNING] + log.expected[WARNING];
   }

   if (err_cnt > 0 || missed_err > 0 || missed_wrn > 0) {
      printf("FAILED! on %s at %d:",
             which, get_time(LO));
      printf(" %0d errors, %0d/%0d missed warn/err\n",
             err_cnt, missed_wrn, missed_err);
   } else {
      printf("PASSED! on %s at %d.\n",
             which, get_time(LO));
   }
}


//
// Increment the error count and
// check if the max # of errors has been reached
//
task syslog::incr_err_cnt()
{
   this.err_cnt++;
   max_err_cnt--;
   if (max_err_cnt == 0) {
      fatal("Maximum number of errors reached.");
   }
}
